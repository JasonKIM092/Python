v1 = int(input('숫자를 입력하세요 : '))
v2 = int(input('숫자를 입력하세요 : '))
v3 = str(v1 / v2)

print('연산결과는 ' + v3 )


jumin = 9012211234567
jumin[6]   # error : 숫자는 추출 불가. 문자열 추출 함수임.
str(jumin)[6]   # 1
str(jumin).startswith('9')   # True


v1 = int(input('지폐로 교환할 돈은 얼마? : '))
v2 = int(v1)//50000
v3 = (int(v1)%50000)//10000
v4 = (int(v1)%10000)//5000
v5 = (int(v1)%5000)//1000
v6 = int(v1)%1000

print('50000원짜리 ==> %d장 ' % v2)
print('10000원짜리 ==> %d장 ' % v3)
print('5000원짜리 ==> %d장 ' % v4)
print('1000원짜리 ==> %d장 ' % v5)
print('지폐로 바꾸지 못한 돈 ==> %d원 ' % v6)


## 선생님
money = int(input('지폐로 교환할 돈은 얼마? '))

q50 = money//50000
money = money % 50000
q10 = money//10000
money = money % 10000
q5 = money//5000
money = money % 5000
q1 = money//1000
money = money % 1000

print('50000원짜리 ==> %d장' % q50)
print('10000원짜리 ==> %d장' % q10)
print(' 5000원짜리 ==> %d장' % q5)
print(' 1000원짜리 ==> %d장' % q1)
print('지폐로 바꾸지 못한 돈 ==> %d원' % money)  # money값을 덮어썼기 때문에 마지막 money가 출력이 된다.

# print 정렬
money = int(input('지폐로 교환할 돈은 얼마? '))

q50 = money//50000
money = money % 50000
q10 = money//10000
money = money % 10000
q5 = money//5000
money = money % 5000
q1 = money//1000
money = money % 1000

print('50000원짜리 ==> %2d장' % q50)
print('10000원짜리 ==> %2d장' % q10)
print(' 5000원짜리 ==> %2d장' % q5)
print(' 1000원짜리 ==> %2d장' % q1)
print('지폐로 바꾸지 못한 돈 ==> %d원' % money)

# 연산자
&, and - 사용가능. &&없음.
|, or - 사용가능. ||없음.
not은 수행됨. !는 수행안됨. ~ 수행안됨. but 데이터프레임에서는 !, ~ 사용 가능하다.

# 리스트
l1 = [1,2,3,4,5]   # 이렇게 만들어준다. 리스트 = R.벡터. R.벡터와 P.리스트는 둘 다 1차원 구조이다.
l1 = [1,2,3,4,'5']   # P.리스트가 R.벡터와 가장 큰 차이점은 P.리스트는 서로 다른 데이터타입을 묶을 수 있다는 점. cf)R.벡터는 서로 다른 데이터 타입을 묶을 수 없다.
l1 = [1,2,3,4,5]
l1 + 10   # error. 스칼라를 통한 반복연산이 안된다. 반복문이나 적용함수를 이용하여 연산을 해야 한다.

l1[0]   # 1. 리스트 원소 추출.
l1[0:2]   # 1,2. 마지막숫자 -1 까지 추출.
type(l1[0])   # class 'int'
type(l1[0:2])   # class 'list'


# 리스트
- 최소 단위 기본 자료구조
- 1차원
- 서로 다른 데이터 타입 허용(R 벡터 불가)
- 중첩 구조 가능(R 벡터 불가. 한개의 벡터로 형성됨.)
# R. v1 <- c(1,2,3) ; c(v1,4) => c(1,2,3,4)
l1 = [1,2,3,4,5]
l2 = [10,20,30]
l3 = [1,2,[10,20]]

# 1. 리스트 생성
l1 = [1,2,3,4,5]
l2 = [10,20,30]
l3 = [1,2,[10,20]]  # 중첩 생성 가능. l3의 원소의 갯수는 3개이다. [10,20]이 하나의 원소임.
l3 출력결과 : [1,2,[10,20]]
len(l3)   # 원소갯수 확인 함수. R에서 벡터 원소 갯수 확인하는 함수인 length()와 동일.

# 2. 리스트 색인(1차원 색인)
l3[0]  # 1. 첫 번째 원소 출력.
l3[1]  # 2. 두 번째 원소 출력.
l3[2]  # [10,20]. 세 번째 원소 출력(리스트로 출력).
l3[2][1]  # 20. 세 번째 원소 중 두 번째 원소.
# 리스트는 첫번째 원소와 세번째 원소 즉, 떨어져있는 원소를 한번의 색인으로 추출이 불가하므로
# 사실상 리스트는 데이터를 담는 목적으로만 사용하지, 보통 색인 목적으로 사용하지는 않는다고 한다.
# 서로 다른 데이터 타입을 허용하기 때문에, 그리고 특정 위치값에 대한 여러가지의 색인이 불가하므로 데이터 프레임의 구성요소가 되지 않는다.
# 리스트는 데이터 프레임으로 확장되는 구조는 아니다.

l1[0:2]  # 1,2. 첫 번째 ~ 두 번째 출력(슬라이스 색인 가능).
l1[[0,2]]  # 여러개 원소 동시 추출 불가(정수 색인(여러개 묶어서 전달하는 벡터 색인) 불가)


# 3. 리스트 수정
l1[4] = 50   # 원소를 선택한 다음 수정할 값을 입력해주는 벡터원소의 수정 방식과 동일

# 4. 리스트 확장
l1 + l2  # 리스트끼리 산술 연산 불가. 결합(확장).
l1[5] = 6  # 불가. R 벡터에서는 이렇게 하면 원소가 추가가 됐음.(확장이 됐음).
l1 = l1 + [6]  # 가능.
l1.append(7)  # 가능. 즉시 수정. 맨 끝에만 원소 추가.
l1.append([8.9])  # [8,9]라는 리스트 형태로 삽입됨. 두개가 추가 되는게 아니라, 한개로 묶여서 한개로 추가됨.
                  # [8,9] 원소 하나 추가.
l1.extend([8,9])  # 8,9가 각각 추가됨. 즉 원소가 2개 추가됨. 즉시 수정. 8,9 원소 두개 추가.

# R에서 벡터 확장(원소추가)
# v1[4] <- 5
# v1 <- c(v1,5)
# v1 <- append(v1,6)

# 5. 리스트 산술연산
l1 + 1  # 벡터의 산술연산 불가하다. 벡터 연산 불가. 벡터연산 : 매 원소마다 반복. 반복문 또는 적용함수 처리.
l1 + l2  # 리스트 + 리스트는 산술연산이 아니라 결합(확장)이 된다.

# 6. 리스트 원소 삭제
del(l1[7])  # 리스트 즉시 삭제.
del(l1)  # 자료구조 자체가 날아감. 리스트 객체 삭제. Not defined.
l2 = []  # l2의 자료구조는 남기고 내용만 삭제하는 방식.혹은 빈리스트 생성. 빈 리스트 선언해주기.
         # 리스트 내용만 삭제, 빈리스트 생성.
l3.remove(1)  # 1이라는 원소 값 자체가 삭제가 됨.
l4 = [1,2,3,1,2]

l4.remove(1)  # [2,3,1,2]. 처음 발견되는 값만 삭제. 처음 발견되는 원소 하나 삭제. 즉시 수정.
l4.pop()  # 맨 끝에 있는 원소 출력. 출력된 원소들은 l4에서 삭제된다.
l4.pop(-1)  # 디폴트 값은 -1.
l4.pop(0)  # 0번째 값 출력 삭제. 첫 번째 원소를 꺼내 출력과 동시에 원본에서 제거.
l4.pop(1)

# - : R -> 제외. P -> 끝에서 부터.
 0  1  2  3  4  5
-6 -5 -4 -3 -2 -1

# 7. 기타 리스트 메서드
l1.count(2)

l1 = [1,1,1,2]
l1.count(1)   # 3. 해당 원소의 갯수 출력.
l1.count(2)   # 1.

l1 = [1,1,1,2,3,1]
l1.sort()   # [1,1,1,1,2,3]
l1.sort(reverse=True)   # [3,2,1,1,1,1]

l1.index(2)   # 1. 위치값. 즉. l1에서 2라는 원소의 위치값 출력.

l1.index(1)   # l1에서 1을 찾아 그 위치. 여러개 값이 있어도 맨 처음 원소의 위치값만 출력.
l1.sort(reverse=True)  # 정렬, 리스트 직접 수정
l1.count(1)   # l1에서 1이 포함된 횟수

# 람다(lambda) : 사용자 정의 함수의 축약형
# 함수명 = lambda 인수 : 연산식(주로 인수 사용)
f(x) = x + 1
f1 = lambda x : x + 1

# 적용함수 : 함수의 반복을 수행
# 1. map 함수 : 리스트(1차원 데이터 구조)의 원소 반복을 수행
list(map(함수, 함수의 인자...))  # 반드시 리스트 형식으로 출력해야 한다. 리스트에만 사용할 수 있다.

l1 = [1,2,3]
l2 = [10,20,30]
f2 = lambda x,y : x + y
list(map(f2, l1, l2))

cf) l1 = ['abcd','bcd']
l1.replace('a','A')   # error. 문자열(문자스칼라, 'abc') 함수라서 리스트 적용은 개별적으로 불가하고, 반복문이나 적용함수를 써야한다.

##[ 연습문제 ]
##다음의 리스트를 생성
l1 = [1,2,3,4]
l2 = [10,20,30,40]
l3 = [100,200,300]
l4 = ['서울','부산','대전','전주']
l5 = ['abc@naver.com','a123@hanmail.net']

##주석처리 단축키 : alt + 3
##주석해제 단축키 : alt + 4 (alt + f4아님 주의)

##1. l2의 l1승 출력, 10^1, 20^2, 30^3, 40^4
f1 = lambda x,y : x**y
list(map(f1,l2,l1))

##2. l1 + l3 출력
f2 = lambda x,y : x+y
list(map(f2, l1, l3))  # 전달되어 지는 인자가 갯수가 다르면, 갯수가 적은쪽에 맞춰서 결과값 출력.

##3. l4의 값에 "시"를 붙여 출력
f3 = lambda x : x+'시'
list(map(f3, l4))

##4. l5에서 이메일 아이디만 출력
f4 = lambda x : x[0 : x.find('@')]
list(map(f4, l5))

f4 = lambda x,y : x[0 : x.find(y)]
list(map(f4, l5, ['@','@']))

f4 = lambda x : x.split('@')[0]
list(map(f4, l5))

f4 = lambda x, sep : x.split(sep)[0]
list(map(f4, l5, ['@','@']))  # l5의 갯수는 2개여서 @의 갯수도 2개로 맞춰줘야 한다. 즉, 원소의 갯수에 맞춰줘야 한다.

##5. l3의 10% 인상값 출력
f5 = lambda x : x*1.1
list(map(f5, l3))

f5 = lambda x : int(x*1.1)
list(map(f5, l3))

f5 = lambda x : round(x*1.1, 2)
list(map(f5, l3))


f6 = lambda x : '%.2f' % x
list(map(f6,l1))

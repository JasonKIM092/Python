l1 = [1,2,3,4]
l1

import numpy
dir(numpy)

for i in l1 : 
    print(i)
    # F9는 라인단위 실행이라서 두 줄을 묶어주고 F9로 실행.
    
# numpy : array(배열)을 구현하는 모듈(패키지)
# 랜덤 배열 생성
arr1 = np.random.randn(4,2)   # 표준정규분포를 따르는 난수를 갖는
# 배열 : 다차원구조, 서로 같은 데이터 타입만을 허용하는 자료구조

import numpy as np

# 1. 배열 생성

arr1 = np.random.randn(4,2)               # 4 x 2 배열 생성
arr1
type(arr1)

# 사용자 지정 배열 생성
l1 = [1,2,3,4,5,6,7,8]
l2 = np.array(l1)   # 1 x 8 배열
l2.shape   # (8,)
np.array(l1).reshape(2,4)   # 2 x 4 배열
                            # reshape : 배열의 크기 설정

np.array([1,2,3,4,5], dtype = 'float')  # 1 x 5 배열
                                        # dtype : 배열 생성 시 데이터 타입 설정
arr2 = np.arange(1,25)   # 정수의 연속값 출력(array 구조)

# 2. 배열의 중요 매서드
arr1.shape   # (4,2) : 4행 2열. 배열 모양을 알려주는 매서드
arr3 = arr2.reshape(2,3,4)   # 2층 3행 4열 구조로 변경. R에서는 2행 3열 4층.
arr3.ndim    # 차원의 수
arr3.dtype   # 배열을 구성하는 원소의 데이터 타입

# 3. 배열의 연산
a1 = np.arange(1,10).reshape(3,3)
a2 = np.array([10,20,30])
a3 = np.arange(10,100,10).reshape(3,3)
a4 = np.arange(1,13).reshape(3,4)

a1 + 1    # 배열과 스칼라의 연산 가능
a1 + a3   # 서로 같은 크기의 배열 연산 가능
a1 + a4   # 서로 다른 크기의 배열 대체적 연산 불가

a1 + a2   # 브로드캐스팅 규칙에 의해 서로 다른 크기 배열 연산 가능
          # (3x3) (1x3) => 행의 수 만큼 반복
a1 + a2.reshape(3,1)   # (3x3) (3x1) => 컬럼의 수 만큼 반복

a2
a2.shape   # (3,) : 1 x 3 배열
s2 = a2.reshape(3,1)
s2.shape   # (3,1) : 3 x 1 배열

# 브로드 캐스팅의 규칙
# (4 x 2) (1 x 2) 처럼
# 1. 작은 크기를 갖는 배열이 1의 크기를 가져야 함
# 2. 두 배열의 한 방향의 크기가 서로 같아야 함


# [참고 : R과 파이썬에서의 다차원 구조 방향]
# 행, 열, 층, ... -> in R
# ..., 층, 행, 열 -> in Python

# 예제) 1부터 1씩 증가하는 5x6 배열을 생성,
arr1 = np.arange(1,31).reshape(5,6)
arr2 = np.array([1,2,3,4,5])
arr2.shape   # (5,). 1x5 배열
arr3 = np.array([1,2,3,4,5,6])

#[참고]
np.array([1,2,3,4])   # 1차원
np.array([[1,2],[3,4]])   # 2차원
np.array([ [[1,2],[3,4]], [[5,6],[7,8]] ])   # 3차원. 층까지 표현.

# 1) 1,2,3,4,5를 각 컬럼마다 반복
# sol1)
arr1 + arr2   # (5x6) (1x5)
arr1 + arr2.reshape(5,1)   # (5x6) (5x1)

# sol2)
arr4 = np.array([[1],[2],[3],[4],[5]])   # 2차원. (5x1)
arr1 + arr4

# 2) 1,2,3,4,5,6을 각 행마다 반복
arr1 + arr3   # (5x6) (1x6)



# 4. 배열의 색인
l1 = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
arr1 = np.array(l1)
l1[1,1]     # 에러. 1차원 구조에서 2차원 형식의 색인 불가
l1[1][1]    # 1차원 구조에서는 연속 색인을 통해 출력 가능
arr1[1,1]   # 2차원 형식의 색인 가능
arr1[0,]    # 첫번째 행만 출력. 두번째 색인 범위 생략 시 해당 행 전체 값 출력.
arr1[0]     # ,까지 생략해도 행이 출력이 됨. 근데 상황에 따라서는 층이 선택될때도 있으니 걍 없다고 생각할 것.
arr1[0,:]   # 위와 같이 생략해도 되지만, 가독성 측면에서는 :을 삽입하는 습관 들이기
arr1[,0]    # 에러. 앞에 있는 색인은 절대로 생략 불가. 첫번째 색인범위 생략 불가(콜론 사용)
arr1[:,0]   # 이런식으로 첫번째 컬럼을 전체 선택할 때는 비워두는게 아니라 :을 삽입하여 색인.

arr1[1:3,2:4]   # 슬라이스 색인 가능. 행,열 결합식.
arr1[1:3, :][:,2:4]   # 위와 동일한 표현. 행선택 후 컬럼선택. 행,열 분리식

arr1[[0,2],:]   # 첫번째, 세번째 행 색인 가능. 리스트 색인 가능(동시에 여러 범위 전달).
arr1[[0,2],[0,3]]   # array([ 1, 12]). 해당 리스트 색인에서는 p(0,0), p(2,3)에 해당하는 값이 선택됨. 포인트 출력으로 바뀜.

# 예제) 다음의 arr2에서 
arr2 = np.arange(1,21).reshape(5,4)
arr2

# 1) 10,11,14,15,18,19 출력
arr2[2:5, 1:3]
arr2[[2,3,4],:][:,[1,2]]
arr2[2:5,:][:,1:3]

arr2[np.ix_([2,3,4],[1,2])]   # 우리가 R에서 많이 쓰던 색인 방식을 numpy에서 ix_() 함수를 쓰면 된다.
                              # arr2[c(2,3,4),c(1,2)]  in R

# 2) 6,7,8 출력
arr2[1,1:4]
arr2[1,[1,2,3]]   # 이게 출력이 되는이유는 행이 리스트가 아니다. 행이 리스트일 경우 분리식으로 써야 한다.
arr2[[1],[1,2,3]]   # 행이 1개라서 실행이 되는거지 원래는 안되는 방식이다. 왠만하면 안된다 생각하고 쓰지말것!!!

